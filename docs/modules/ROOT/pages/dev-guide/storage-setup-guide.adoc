= Guide de Configuration du Stockage pour l'Auto-Initialisation
:description: Configuration compl√®te du stockage MinIO pour l'auto-initialisation des vrais datasets
:keywords: MinIO, stockage, configuration, auto-initialisation, d√©veloppement

== Vue d'Ensemble

Pour que l'**auto-initialisation des vrais datasets** fonctionne, le syst√®me EXAI n√©cessite un stockage d'objets configur√©. Cette page explique comment tout est automatiquement configur√© pour vous.

== ‚úÖ Configuration Automatique Incluse

**Bonne nouvelle !** Toute l'infrastructure de stockage est maintenant **automatiquement d√©ploy√©e** avec votre environnement EXAI :

=== Composants Automatiquement D√©ploy√©s

[cols="2,3,2"]
|===
|Composant |Description |Statut

|**MinIO Server**
|Stockage d'objets compatible S3 pour d√©veloppement
|‚úÖ Auto-d√©ploy√©

|**MinIO Service**
|Service Kubernetes pour acc√®s interne
|‚úÖ Auto-configur√©

|**Stockage Persistant**
|Volume persistant de 5Go pour MinIO
|‚úÖ Auto-cr√©√©

|**Secrets Unifi√©s**
|Credentials MinIO et Azure pr√©-configur√©s
|‚úÖ Pr√©-configur√©

|**Variables d'Environnement**
|Configuration automatique des services
|‚úÖ Auto-inject√©es
|===

=== Configuration Automatique des Services

Lorsque vous d√©marrez avec `make dev-with-data`, voici ce qui se passe automatiquement :

1. **MinIO d√©ploy√©** : Server MinIO d√©marr√© avec stockage persistant
2. **Service expos√©** : MinIO accessible via `minio-service.exai.svc.cluster.local:9000`
3. **Bucket cr√©√©** : Bucket `exai-datasets` cr√©√© automatiquement
4. **Service-selection configur√©** : Variables d'environnement inject√©es automatiquement
5. **Auto-init activ√©e** : Initialisation des vrais datasets au d√©marrage

== üîß Variables d'Environnement Automatiques

=== Service-Selection (Automatique)

[source,yaml]
----
env:
  - name: STORAGE_BACKEND
    value: "minio"
  - name: STORAGE_ENDPOINT_URL
    value: "http://minio-service.exai.svc.cluster.local:9000"
  - name: STORAGE_CONTAINER_NAME
    value: "exai-datasets"
  - name: STORAGE_ACCESS_KEY
    valueFrom:
      secretKeyRef:
        name: storage-secrets
        key: access-key  # = minioadmin
  - name: STORAGE_SECRET_KEY
    valueFrom:
      secretKeyRef:
        name: storage-secrets  
        key: secret-key  # = minioadmin
----

=== Credentials par D√©faut

[source,bash]
----
# Credentials MinIO (pr√©-configur√©s)
Username: minioadmin
Password: minioadmin
Endpoint: http://minio-service.exai.svc.cluster.local:9000
Bucket: exai-datasets
----

== üöÄ D√©marrage Imm√©diat

Aucune configuration manuelle n√©cessaire ! Lancez simplement :

[source,bash]
----
make dev-with-data
----

**Ce qui se passe automatiquement :**

1. ‚úÖ **Minikube d√©marr√©** avec configuration optimale
2. ‚úÖ **Namespace `exai` cr√©√©**
3. ‚úÖ **PostgreSQL d√©ploy√©** avec stockage persistant
4. ‚úÖ **MinIO d√©ploy√©** avec stockage persistant (NOUVEAU !)
5. ‚úÖ **Services applicatifs d√©ploy√©s** avec variables d'environnement
6. ‚úÖ **Migrations de base de donn√©es** ex√©cut√©es
7. ‚úÖ **Auto-initialisation des vrais datasets** avec conversion Parquet
8. ‚úÖ **Logs en temps r√©el** affich√©s

== üîç V√©rification du Stockage

=== V√©rifier MinIO

[source,bash]
----
# V√©rifier que MinIO est d√©marr√©
kubectl get pods -n exai -l app=minio

# V√©rifier le service MinIO
kubectl get service minio-service -n exai

# V√©rifier les logs MinIO
kubectl logs -f deployment/minio -n exai
----

=== V√©rifier les Datasets Upload√©s

[source,bash]
----
# V√©rifier que les datasets sont dans la base
kubectl exec -n exai deployment/service-selection -- python -c "
import sys; sys.path.append('/app')
from app.database import SessionLocal
from app.models import Dataset
with SessionLocal() as db:
    datasets = db.query(Dataset).all()
    for d in datasets:
        print(f'üìä {d.name}: {d.storage_path} ({d.row_count} lignes)')
"

# Tester l'acc√®s au stockage depuis le service
kubectl exec -n exai deployment/service-selection -- python -c "
import sys; sys.path.append('/app/..')
from common.storage_client import get_storage_client
try:
    client = get_storage_client()
    print('‚úÖ Connexion stockage OK')
except Exception as e:
    print(f'‚ùå Erreur stockage: {e}')
"
----

== üåê Acc√®s √† l'Interface MinIO (Optionnel)

Si vous souhaitez acc√©der √† l'interface web de MinIO pour d√©bugger :

[source,bash]
----
# Cr√©er un port-forward vers MinIO Console
kubectl port-forward -n exai service/minio-service 9001:9001

# Acc√©der √† l'interface via : http://localhost:9001
# Credentials : minioadmin / minioadmin
----

== üìä Monitoring du Stockage

=== V√©rifier l'Espace de Stockage

[source,bash]
----
# V√©rifier l'utilisation du PVC MinIO
kubectl get pvc minio-data-pvc -n exai

# V√©rifier les d√©tails du volume
kubectl describe pvc minio-data-pvc -n exai
----

=== Surveiller les Uploads

[source,bash]
----
# Surveiller les logs d'upload en temps r√©el
kubectl logs -f deployment/service-selection -n exai | grep -i "upload\|storage\|parquet"
----

== üîß D√©pannage

=== Probl√®mes Courants

[cols="2,3,3"]
|===
|Probl√®me |Sympt√¥me |Solution

|MinIO ne d√©marre pas
|Pod en `CrashLoopBackOff`
|V√©rifier les logs : `kubectl logs deployment/minio -n exai`

|PVC pas attach√©
|Pod en `Pending`
|V√©rifier la classe de stockage : `kubectl get storageclass`

|Connexion refus√©e
|Erreur "connection refused"
|V√©rifier le service : `kubectl get svc minio-service -n exai`

|Upload √©choue
|Erreur lors de l'auto-init
|V√©rifier les credentials dans les secrets : `kubectl get secret storage-secrets -n exai -o yaml`

|Variables d'env manquantes
|Service ne trouve pas le stockage
|V√©rifier que le pod service-selection a les bonnes env vars
|===

=== Commandes de Diagnostic

[source,bash]
----
# Diagnostic complet du stockage
echo "=== √âtat MinIO ==="
kubectl get all -n exai -l app=minio

echo "=== √âtat PVC ==="
kubectl get pvc -n exai

echo "=== Secrets Stockage ==="
kubectl get secret storage-secrets -n exai

echo "=== Variables Env Service-Selection ==="
kubectl exec -n exai deployment/service-selection -- env | grep STORAGE

echo "=== Test Connexion ==="
kubectl exec -n exai deployment/service-selection -- python -c "
import sys; sys.path.append('/app/..')
from common.storage_client import get_storage_client
try:
    client = get_storage_client()
    print('‚úÖ Connexion r√©ussie')
except Exception as e:
    print(f'‚ùå Erreur: {e}')
"
----

== üè≠ Production Azure

En production, le syst√®me bascule automatiquement vers **Azure Blob Storage** gr√¢ce au patch Kustomize :

[source,yaml]
----
# k8s/overlays/azure/storage-config-patch.yaml
env:
  - name: STORAGE_BACKEND
    value: "azure"  # Bascule vers Azure
  - name: STORAGE_ENDPOINT_URL
    value: "https://your-storage-account.blob.core.windows.net"
----

**Avantages Azure :**
* üåê G√©o-r√©plication automatique
* üîí S√©curit√© enterprise
* üìà Scalabilit√© illimit√©e
* üí∞ Mod√®le de co√ªt √† l'usage

== ‚úÖ R√©sum√©

**Vous n'avez rien √† configurer manuellement !**

‚úÖ **MinIO** : D√©ploy√© automatiquement  
‚úÖ **Stockage** : 5Go de PVC persistant  
‚úÖ **Secrets** : Credentials pr√©-configur√©s  
‚úÖ **Variables** : Injection automatique  
‚úÖ **Auto-init** : Vrais datasets upload√©s automatiquement

Lancez simplement `make dev-with-data` et profitez de votre syst√®me EXAI avec vrais datasets automatiquement initialis√©s ! üéâ 