# Version de la syntaxe Docker Compose utilisée.
version: '3.8'

# Définition des services qui composent notre application locale.
services:

  # Service pour la base de données PostgreSQL
  db:
    # Image Docker à utiliser pour ce service.
    # On utilise une image officielle PostgreSQL version 15 basée sur Alpine Linux (légère).
    image: postgres:15-alpine
    # Nom donné au conteneur une fois lancé (plus facile à identifier).
    container_name: selection_db
    # Variables d'environnement pour configurer PostgreSQL à l'intérieur du conteneur.
    environment:
      POSTGRES_USER: user           # Nom de l'utilisateur de la base de données
      POSTGRES_PASSWORD: password   # Mot de passe pour cet utilisateur
      POSTGRES_DB: exaidb           # Nom de la base de données à créer au démarrage
    # Volumes pour persister les données de la base de données.
    # - `postgres_data` est un volume nommé (défini plus bas).
    # - `/var/lib/postgresql/data` est le répertoire où PostgreSQL stocke ses données dans le conteneur.
    # Ainsi, même si le conteneur est supprimé, les données persistent dans le volume.
    volumes:
      - postgres_data:/var/lib/postgresql/data
    # Mappage des ports.
    # - On expose le port 5432 (port par défaut de PostgreSQL) du conteneur
    #   sur le port 5433 de la machine hôte. Cela évite les conflits si PostgreSQL
    #   tourne déjà sur le port 5432 de l'hôte.
    ports:
      - "5433:5432"
    # Réseau auquel ce service appartient.
    # Permet à ce service de communiquer avec d'autres services sur le même réseau (ici, l'API).
    networks:
      - exai_network

  # Service pour notre API FastAPI (service-selection)
  api:
    # Configuration du build de l'image Docker pour ce service.
    build:
      # Contexte de build : le répertoire courant (`.`), où se trouve le Dockerfile.
      context: .
      # Nom du Dockerfile à utiliser pour construire l'image.
      dockerfile: Dockerfile
    # Nom du conteneur pour l'API.
    container_name: selection_api
    # Dépendances : ce service ne démarrera qu'après que le service `db` soit prêt.
    depends_on:
      - db
    # Mappage des ports.
    # - On expose le port 8081 (où Uvicorn écoute dans le conteneur, cf Dockerfile)
    #   sur le port 8081 de la machine hôte.
    ports:
      - "8081:8081"
    # Variables d'environnement pour l'API.
    environment:
      # URL de connexion à la base de données.
      # `db` est le nom du service PostgreSQL défini plus haut.
      # Docker Compose gère la résolution de nom entre les services sur le même réseau.
      DATABASE_URL: postgresql://user:password@db:5432/exaidb
    # Volumes pour le développement.
    # - On monte le répertoire courant (`.`) de l'hôte dans le répertoire `/app` du conteneur.
    # - Cela permet de voir les modifications du code local immédiatement dans le conteneur
    #   sans avoir à reconstruire l'image. Très utile avec `--reload` d'Uvicorn.
    #   À supprimer ou adapter pour un environnement de production.
    volumes:
      - .:/app # Mount current directory for live reload (dev only)
    # Commande à exécuter au démarrage du conteneur.
    # Surcharge la commande `CMD` du Dockerfile si nécessaire.
    # Ici, on lance Uvicorn avec l'option `--reload` pour le développement.
    command: uvicorn main:app --host 0.0.0.0 --port 8081 --reload
    # Réseau auquel ce service appartient.
    networks:
      - exai_network

# Définition des volumes nommés utilisés par les services.
volumes:
  # Volume pour stocker les données PostgreSQL.
  postgres_data:
    # Type de driver pour le volume (par défaut `local`).
    driver: local

# Définition des réseaux personnalisés.
networks:
  # Notre réseau personnalisé pour que les conteneurs puissent communiquer.
  exai_network:
    # Type de driver pour le réseau (par défaut `bridge`).
    driver: bridge 