import { Component, ElementRef, OnInit, OnDestroy, Input, ViewChild, NgZone } from '@angular/core';
import { isPlatformBrowser } from '@angular/common';
import { PLATFORM_ID, Inject } from '@angular/core';

// Import Three.js modules
declare var THREE: any;

@Component({
  selector: 'app-login-background-animation',
  standalone: true,
  template: `
    <div class="animation-container" [class.mobile-fallback]="isMobile">
      <canvas #threeCanvas 
              class="three-canvas"
              [style.opacity]="canvasOpacity">
      </canvas>
      <div class="fallback-gradient" [style.opacity]="fallbackOpacity"></div>
    </div>
  `,
  styleUrls: ['./login-background-animation.component.scss']
})
export class LoginBackgroundAnimationComponent implements OnInit, OnDestroy {
  @ViewChild('threeCanvas', { static: true }) canvasRef!: ElementRef<HTMLCanvasElement>;
  
  @Input() animationType: 'sorbonne-3d' | 'fallback' = 'sorbonne-3d';
  @Input() maxWidth: number = 600;
  @Input() height: number = 450;

  // Three.js variables
  private canvas!: HTMLCanvasElement;
  private renderer!: any;
  private scene!: any;
  private camera!: any;
  private rotatingGroup!: any;
  private controls!: any; // OrbitControls pour interaction souris
  private animationId!: number;
  private isAnimating = false;

  // Responsive et performance
  public isMobile = false;
  public canvasOpacity = 0;
  public fallbackOpacity = 1;

  constructor(
    @Inject(PLATFORM_ID) private platformId: Object,
    private ngZone: NgZone
  ) {}

  ngOnInit(): void {
    console.log('üöÄ LOGIN ANIMATION COMPONENT STARTING...');
    console.log('Platform:', this.platformId);
    console.log('Canvas ref:', this.canvasRef);
    
    if (isPlatformBrowser(this.platformId)) {
      console.log('‚úÖ Platform is browser, proceeding...');
      this.checkMobileDevice();
      
      // FORCER l'animation m√™me sur mobile pour debug
      console.log('üîß FORCING Three.js load (debug mode)...');
      this.isMobile = false; // FORCER pour debug
      
      this.loadThreeJS();
    } else {
      console.log('‚ùå Not browser platform, showing fallback');
      this.showFallback();
    }
  }

  ngOnDestroy(): void {
    this.cleanup();
  }

  private checkMobileDevice(): void {
    this.isMobile = window.innerWidth <= 768 || /Android|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
    
    if (this.isMobile) {
      // Sur mobile, on montre juste le gradient statique
      this.canvasOpacity = 0;
      this.fallbackOpacity = 1;
      return;
    }
  }

  private async loadThreeJS(): Promise<void> {
    console.log('üöÄ Loading Three.js + OrbitControls as ES6 MODULES (EXACTLY like working example)...');
    if (this.isMobile) {
      console.log('üì± Mobile detected, skipping Three.js');
      return;
    }

    // Check WebGL support
    if (!this.isWebGLSupported()) {
      console.log('‚ùå WebGL not supported, showing fallback');
      this.showFallback();
      return;
    }

    try {
      // Load EVERYTHING as ES6 modules (EXACTLY like the working example)
      console.log('üì¶ Loading Three.js + OrbitControls as ES6 modules...');
      
      const moduleScript = document.createElement('script');
      moduleScript.type = 'module';
      moduleScript.innerHTML = `
        // Import EXACTLY like the working example
        import * as THREE from 'https://cdn.skypack.dev/three@0.136.0/build/three.module.js';
        import { OrbitControls } from 'https://cdn.skypack.dev/three@0.136.0/examples/jsm/controls/OrbitControls.js';
        
        // Attach to window SEPARATELY (THREE is not extensible!)
        window.THREE = THREE;
        window.OrbitControls = OrbitControls; // ‚úÖ S√âPAR√â !
        
        console.log('‚úÖ Three.js + OrbitControls loaded as ES6 modules!', {
          THREE: !!window.THREE,
          OrbitControls: !!window.OrbitControls
        });
        
        // Notify Angular that everything is ready
        window.dispatchEvent(new CustomEvent('threeAndOrbitControlsReady'));
      `;
      
      await new Promise((resolve, reject) => {
        const handleReady = () => {
          if ((window as any).THREE && (window as any).OrbitControls) {
            console.log('‚úÖ THREE + OrbitControls confirmed ready!');
            window.removeEventListener('threeAndOrbitControlsReady', handleReady);
            resolve(true);
          } else {
            reject(new Error('THREE or OrbitControls not found after ready event'));
          }
        };
        
        window.addEventListener('threeAndOrbitControlsReady', handleReady);
        
        moduleScript.onerror = (error) => {
          console.error('‚ùå Failed to load Three.js module:', error);
          window.removeEventListener('threeAndOrbitControlsReady', handleReady);
          reject(new Error('Failed to load Three.js module'));
        };
        
        // Timeout de s√©curit√©
        setTimeout(() => {
          window.removeEventListener('threeAndOrbitControlsReady', handleReady);
          reject(new Error('Three.js module loading timeout'));
        }, 15000);
        
        document.head.appendChild(moduleScript);
        console.log('üì¶ Three.js ES6 module script injected');
      });

      // Wait for Angular to render the canvas
      setTimeout(() => {
        try {
          const THREE = (window as any).THREE;
          this.setupThreeSceneBasic(THREE);
          console.log('üé® Three.js scene setup completed!');
        } catch (setupError) {
          console.error('‚ùå Failed to setup Three.js scene:', setupError);
          this.showFallback();
        }
      }, 100);
      
    } catch (error) {
      console.error('‚ùå Failed to load Three.js:', error);
      this.showFallback();
    }
  }

  private isWebGLSupported(): boolean {
    try {
      const canvas = document.createElement('canvas');
      const context = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
      return !!context;
    } catch (e) {
      return false;
    }
  }

  private loadScriptFromCDN(src: string): Promise<void> {
    return new Promise((resolve, reject) => {
      // Check if script already exists
      const existingScript = document.querySelector(`script[src*="three"]`);
      if (existingScript) {
        console.log('üì¶ Three.js script already exists, checking THREE object...');
        if ((window as any).THREE) {
          console.log('‚úÖ THREE object already available');
          resolve();
          return;
        }
      }

      console.log('üì¶ Loading script from:', src);
      const script = document.createElement('script');
      script.src = src;
      script.crossOrigin = 'anonymous'; // Add CORS support
      script.onload = () => {
        console.log('‚úÖ Script loaded successfully:', src);
        // Check if THREE is now available
        if ((window as any).THREE) {
          console.log('‚úÖ THREE object is available');
          resolve();
        } else {
          console.log('‚ùå THREE object not found after script load');
          reject(new Error(`THREE object not found after loading: ${src}`));
        }
      };
      script.onerror = (error) => {
        console.error('‚ùå Failed to load script:', src, error);
        reject(new Error(`Failed to load script: ${src}`));
      };
      document.head.appendChild(script);
    });
  }



  private setupThreeSceneBasic(THREE: any): void {
    console.log('üé¨ Setting up Three.js scene...');
    console.log('Canvas element:', this.canvasRef?.nativeElement);
    console.log('Canvas size:', this.maxWidth, 'x', this.height);
    
    this.canvas = this.canvasRef.nativeElement;
    
    if (!this.canvas) {
      throw new Error('Canvas element not found!');
    }
    
    // Setup renderer avec fond TRANSPARENT
    console.log('üñ•Ô∏è Creating WebGL renderer...');
    this.renderer = new THREE.WebGLRenderer({ 
      canvas: this.canvas,
      antialias: true,
      alpha: true // TRANSPARENT !
    });
    this.renderer.setClearColor(0x000000, 0); // Fond transparent
    this.renderer.setSize(this.maxWidth, this.height);
    this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    console.log('‚úÖ Renderer created with transparency');

    // Setup scene avec fond TRANSPARENT
    console.log('üé≠ Creating scene...');
    this.scene = new THREE.Scene();
    // PAS de background = transparent !
    console.log('‚úÖ Scene created with transparent background');
    
    // Setup camera - centr√©e pour vue g√©n√©rale
    console.log('üì∑ Setting up camera...');
    this.camera = new THREE.PerspectiveCamera(45, this.maxWidth / this.height, 0.1, 100);
    this.camera.position.set(0, 0, 5); // Cam√©ra centr√©e
    this.camera.lookAt(0, 0, 0); // Regarde le centre
    console.log('‚úÖ Camera positioned centrally');

    // Setup OrbitControls SIMPLE comme l'exemple qui fonctionne !
    console.log('üñ±Ô∏è Setting up REAL OrbitControls...');
    const OrbitControls = (window as any).OrbitControls; // ‚úÖ S√âPAR√â de THREE !
    this.controls = new OrbitControls(this.camera, this.renderer.domElement);
    
    // Configuration pour activer l'interaction souris SANS LIMITES !
    this.controls.enableDamping = true;
    this.controls.dampingFactor = 0.1;
    this.controls.enableRotate = true;  // ‚úÖ ACTIVER rotation souris !
    this.controls.enableZoom = true;    // ‚úÖ ACTIVER zoom molette !
    this.controls.enablePan = false;    // ‚ùå D√âSACTIVER pan (d√©placement)
    this.controls.rotateSpeed = 1.0;    // Sensibilit√© rotation
    this.controls.zoomSpeed = 1.2;      // Sensibilit√© zoom
    
    // ‚úÖ SUPPRIMER toutes les limites pour libert√© totale !
    this.controls.minDistance = 0;     // Pas de limite zoom avant
    this.controls.maxDistance = Infinity; // Pas de limite zoom arri√®re
    this.controls.minPolarAngle = 0;    // Rotation verticale libre
    this.controls.maxPolarAngle = Math.PI; // Rotation verticale libre
    this.controls.minAzimuthAngle = -Infinity; // Rotation horizontale libre
    this.controls.maxAzimuthAngle = Infinity;  // Rotation horizontale libre
    
    console.log('‚úÖ REAL OrbitControls configured for mouse interaction!', {
      enableRotate: this.controls.enableRotate,
      enableZoom: this.controls.enableZoom,
      domElement: this.controls.domElement?.tagName,
      rendererDomElement: this.renderer.domElement?.tagName,
      canvasElement: this.canvas?.tagName,
      sameElement: this.renderer.domElement === this.canvas
    });

    // OrbitControls op√©rationnels - debug termin√©
    console.log('‚úÖ OrbitControls configured and ready for interaction!');

    // Setup rotating group - D√âCAL√â 15% PLUS VERS LA GAUCHE
    console.log('üîÑ Creating rotating group...');
    this.rotatingGroup = new THREE.Group();
    this.rotatingGroup.position.set(-0.75, 0, 0); // D√©calage 15% plus vers la gauche : -0.3 - 0.45 = -0.75
    this.scene.add(this.rotatingGroup);
    console.log('‚úÖ Rotating group added to scene (shifted 15% MORE to LEFT)');

    // Create starfield background - Couleurs Sorbonne
    console.log('‚≠ê Creating starfield...');
    this.createStarfield(THREE);
    console.log('‚úÖ Starfield created');
    
    // Create main objects - Couleurs Sorbonne
    console.log('üéØ Creating main 3D objects...');
    this.createMainObjects(THREE);
    console.log('‚úÖ Main objects created');
    
    // Setup basic event listeners (without shockwave for now)
    console.log('üñ±Ô∏è Setting up event listeners...');
    this.setupBasicEventListeners();
    console.log('‚úÖ Event listeners set up');
    
    // Start animation
    console.log('üé® Showing canvas and starting animation...');
    this.canvasOpacity = 1;
    this.fallbackOpacity = 0;
    this.isAnimating = true;
    console.log('üîÑ Animation status:', this.isAnimating);
    console.log('üéØ Rotating group exists:', !!this.rotatingGroup);
    console.log('üñ±Ô∏è OrbitControls exists:', !!this.controls);
    this.ngZone.runOutsideAngular(() => {
      this.animate();
    });
    console.log('üöÄ Animation started!');
  }

  private createStarfield(THREE: any): void {
    console.log('‚≠ê Creating subtle white starfield...');
    const starGeometry = new THREE.BufferGeometry();
    const starCount = 200; // R√©duit pour discr√©tion
    const starsPositions = new Float32Array(starCount * 3);
    
    for (let i = 0; i < starCount * 3; i++) {
      starsPositions[i] = (Math.random() - 0.5) * 80; // Zone r√©duite
    }
    
    starGeometry.setAttribute('position', new THREE.BufferAttribute(starsPositions, 3));
    
    // √âtoiles BLANC/GRIS TR√àS SUBTIL
    const starMaterial = new THREE.PointsMaterial({
      color: 0xf0f0f0, // BLANC CASS√â tr√®s discret
      size: 0.03, // Tr√®s petites
      sizeAttenuation: true,
      transparent: true,
      opacity: 0.2 // ULTRA discr√®tes pour harmonie
    });
    
    const stars = new THREE.Points(starGeometry, starMaterial);
    this.scene.add(stars);
    console.log('‚úÖ Subtle white starfield created');
  }

  private createMainObjects(THREE: any): void {
    // TAILLES OPTIMIS√âES - r√©duites de 7% pour ajustement final
    console.log('üéØ Creating objects with sizes reduced by 7%...');
    
    // Inner icosahedron - PRESQUE TRANSLUCIDE DOR√â SORBONNE TR√àS TR√àS CLAIR (-7%)
    const innerGeometry = new THREE.IcosahedronGeometry(0.818, 1); // 0.88 * 0.93 = 0.818
    const innerMaterial = new THREE.MeshStandardMaterial({
      color: 0xf5f0e8, // DOR√â SORBONNE TR√àS TR√àS CLAIR (presque blanc dor√©)
      roughness: 0.1, // Tr√®s lisse pour effet translucide
      metalness: 0.05, // Quasi pas m√©tallique = effet fant√¥me
      flatShading: false, // Smooth pour effet translucide
      transparent: true,
      opacity: 0.12 // ULTRA TRANSPARENT ! (presque invisible)
    });
    const innerMesh = new THREE.Mesh(innerGeometry, innerMaterial);
    this.rotatingGroup.add(innerMesh);
    console.log('‚úÖ Inner icosahedron created (ultra translucent golden Sorbonne)');
    
    // Outer wireframe - BLEU SORBONNE (premier plan visible) r√©duit de 7%
    const outerGeometry = new THREE.IcosahedronGeometry(0.972, 1); // 1.045 * 0.93 = 0.972
    const wireframeMaterial = new THREE.MeshBasicMaterial({
      color: 0x242e54, // BLEU SORBONNE pour premier plan !
      wireframe: true,
      transparent: true,
      opacity: 0.8 // Bien visible comme forme principale
    });
    const wireframeMesh = new THREE.Mesh(outerGeometry, wireframeMaterial);
    this.rotatingGroup.add(wireframeMesh);
    console.log('‚úÖ Wireframe created (Sorbonne blue, +15% bigger)');
    
    // Points DOR√âS SORBONNE aux intersections/vertices - COMME DEMAND√â !
    console.log('‚ú® Creating GOLDEN SORBONNE intersection points...');
    const positions = [];
    const posAttr = outerGeometry.attributes.position;
    for (let i = 0; i < posAttr.count; i++) {
      positions.push(posAttr.getX(i), posAttr.getY(i), posAttr.getZ(i));
    }
    
    const goldenPointsGeometry = new THREE.BufferGeometry();
    goldenPointsGeometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
    const goldenPointsMaterial = new THREE.PointsMaterial({
      color: 0xd4a574, // DOR√â SORBONNE - couleur officielle !
      size: 0.051, // R√©duit de 7% : 0.055 * 0.93 = 0.051
      sizeAttenuation: true,
      transparent: true,
      opacity: 0.95 // Bien visibles comme points d'intersections
    });
    const goldenPoints = new THREE.Points(goldenPointsGeometry, goldenPointsMaterial);
    this.rotatingGroup.add(goldenPoints);
    console.log('‚úÖ Golden Sorbonne intersection points created!');
    
    // Add lighting (optimis√© pour dor√© translucide tr√®s clair)
    const light = new THREE.PointLight(0xffffff, 0.6); // LUMI√àRE DOUCE pour r√©v√©ler le dor√©
    light.position.set(3, 2, 4); // Position pour √©clairer d√©licatement
    this.scene.add(light);
    
    // Ambient light dor√©e tr√®s subtile pour harmonie
    const ambientLight = new THREE.AmbientLight(0xfaf8f5, 0.4); // Ambiant dor√© tr√®s clair
    this.scene.add(ambientLight);
    
    // Lumi√®re dor√©e d'appoint pour r√©v√©ler la translucidit√©
    const goldenLight = new THREE.PointLight(0xf5f0e8, 0.2); // DOR√â TR√àS SUBTIL
    goldenLight.position.set(-1, 1, 2); // Proche du centre translucide
    this.scene.add(goldenLight);
    
    console.log('‚úÖ Lighting optimized for ultra translucent golden');
  }



  private setupBasicEventListeners(): void {
    // Simple click interaction - rotation boost
    this.canvas.addEventListener('click', (event) => {
      // Add some rotation boost on click
      this.rotatingGroup.rotation.x += 0.2;
      this.rotatingGroup.rotation.y += 0.3;
    });
  }

  private animate(): void {
    if (!this.isAnimating) {
      console.log('‚èπÔ∏è Animation stopped');
      return;
    }

    this.animationId = requestAnimationFrame(() => this.animate());

    // Update OrbitControls - SIMPLE comme l'exemple !
    this.controls.update();

    // Rotate the main group automatiquement - SIMPLE comme l'exemple !
    this.rotatingGroup.rotation.x += 0.002;
    this.rotatingGroup.rotation.y += 0.003;

    // Render - SIMPLE comme l'exemple !
    this.renderer.render(this.scene, this.camera);
  }

  private showFallback(): void {
    console.log('üîô Showing fallback (animation failed)');
    this.canvasOpacity = 0;
    this.fallbackOpacity = 1;
  }

  private cleanup(): void {
    this.isAnimating = false;
    if (this.animationId) {
      cancelAnimationFrame(this.animationId);
    }
    if (this.controls) {
      // Cleanup OrbitControls events
      this.controls.enabled = false;
    }
    if (this.renderer) {
      this.renderer.dispose();
    }
  }
}