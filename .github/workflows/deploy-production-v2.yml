name: Deploy Production IBIS-X v2 (Script Intelligent)

on:
  push:
    branches:
      - production
  workflow_dispatch:  # Permettre le d√©clenchement manuel

env:
  # Variables d'environnement pour le mode PRODUCTION
  GITHUB_ACTIONS: 'true'
  IS_PRODUCTION: 'true'
  
  # Configuration Azure - NOMS FIXES (corrig√©s pour correspondre √† Terraform)
  AZURE_RESOURCE_GROUP: 'ibis-x-prod-rg'
  AKS_CLUSTER_NAME: 'ibis-x-prod-aks'
  K8S_NAMESPACE: 'ibis-x'
  
  # Configuration de l'application
  WITH_DATA: 'true'

jobs:
  deploy:
    name: üöÄ D√©ploiement Production Intelligent
    runs-on: ubuntu-latest
    
    steps:
      - name: üì• Checkout du code
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.PAT_TOKEN }}

      - name: üîê Connexion √† Azure
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: üõ†Ô∏è Installation des outils
        run: |
          # Installer jq pour le parsing JSON
          sudo apt-get update && sudo apt-get install -y jq
          
          # Installer kubectl (derni√®re version)
          curl -LO "https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl"
          sudo install -o root -g root -m 0755 kubectl /usr/local/bin/kubectl
          kubectl version --client
          
          # Installer Terraform
          wget -O- https://apt.releases.hashicorp.com/gpg | gpg --dearmor | sudo tee /usr/share/keyrings/hashicorp-archive-keyring.gpg
          echo "deb [signed-by=/usr/share/keyrings/hashicorp-archive-keyring.gpg] https://apt.releases.hashicorp.com $(lsb_release -cs) main" | sudo tee /etc/apt/sources.list.d/hashicorp.list
          sudo apt update && sudo apt install terraform

      - name: üîç D√©couverte Dynamique de l'Infrastructure Azure
        id: discover_infrastructure
        run: |
          echo "üîç D√©couverte automatique de l'infrastructure Azure existante..."
          
          # R√©cup√©rer l'ACR existant dans le resource group
          ACR_NAME=$(az acr list --resource-group "${{ env.AZURE_RESOURCE_GROUP }}" --query "[0].name" -o tsv 2>/dev/null || echo "")
          
          if [[ -z "$ACR_NAME" ]]; then
            echo "‚ùå Aucun ACR trouv√© dans le resource group ${{ env.AZURE_RESOURCE_GROUP }}"
            echo "üîç Tentative de recherche dans tous les resource groups..."
            
            # Rechercher dans tous les RG avec pattern ibis-x
            ACR_NAME=$(az acr list --query "[?contains(name, 'ibis') || contains(name, 'prod')].name" -o tsv | head -1 || echo "")
            
            if [[ -z "$ACR_NAME" ]]; then
              echo "‚ùå ERREUR CRITIQUE: Aucun ACR trouv√© ! Infrastructure manquante."
              echo "üí° Solution: Cr√©ez l'infrastructure avec 'terraform apply' ou le script de d√©ploiement manuel."
              exit 1
            fi
            
            # R√©cup√©rer le vrai resource group de l'ACR trouv√©
            REAL_RG=$(az acr show --name "$ACR_NAME" --query "resourceGroup" -o tsv)
            echo "‚ö†Ô∏è ACR trouv√© dans un autre resource group: $REAL_RG"
            echo "AZURE_RESOURCE_GROUP=$REAL_RG" >> $GITHUB_ENV
          fi
          
          # V√©rifier l'AKS dans le m√™me resource group
          AKS_NAME=$(az aks list --resource-group "${{ env.AZURE_RESOURCE_GROUP }}" --query "[0].name" -o tsv 2>/dev/null || echo "")
          
          if [[ -z "$AKS_NAME" ]]; then
            echo "‚ùå Aucun cluster AKS trouv√© dans le resource group ${{ env.AZURE_RESOURCE_GROUP }}"
            # Rechercher avec pattern
            AKS_NAME=$(az aks list --query "[?contains(name, 'ibis') || contains(name, 'prod')].name" -o tsv | head -1 || echo "")
            
            if [[ -z "$AKS_NAME" ]]; then
              echo "‚ùå ERREUR CRITIQUE: Aucun cluster AKS trouv√© !"
              exit 1
            fi
          fi
          
          echo "‚úÖ Infrastructure d√©couverte:"
          echo "  ACR: $ACR_NAME"
          echo "  AKS: $AKS_NAME"
          echo "  Resource Group: ${{ env.AZURE_RESOURCE_GROUP }}"
          
          # Exporter les variables pour les √©tapes suivantes
          echo "AZURE_CONTAINER_REGISTRY=$ACR_NAME" >> $GITHUB_ENV
          echo "AKS_CLUSTER_NAME=$AKS_NAME" >> $GITHUB_ENV
          
          # Outputs pour debugging
          echo "acr_name=$ACR_NAME" >> $GITHUB_OUTPUT
          echo "aks_name=$AKS_NAME" >> $GITHUB_OUTPUT

      - name: üîë Injection des secrets production dans les fichiers YAML
        run: |
          echo "üîê Injection des secrets de production dans les fichiers K8s..."
          
          # Encodage Base64 des secrets
          SECRET_KEY_B64=$(echo -n "${{ secrets.JWT_SECRET_KEY }}" | base64 -w 0)
          DATABASE_URL_B64=$(echo -n "${{ secrets.DATABASE_URL }}" | base64 -w 0)
          GOOGLE_CLIENT_ID_B64=$(echo -n "${{ secrets.GOOGLE_CLIENT_ID }}" | base64 -w 0)
          GOOGLE_CLIENT_SECRET_B64=$(echo -n "${{ secrets.GOOGLE_CLIENT_SECRET }}" | base64 -w 0)
          OAUTH_REDIRECT_URL_B64=$(echo -n "${{ secrets.OAUTH_REDIRECT_URL }}" | base64 -w 0)
          KAGGLE_USERNAME_B64=$(echo -n "${{ secrets.KAGGLE_USERNAME }}" | base64 -w 0)
          KAGGLE_KEY_B64=$(echo -n "${{ secrets.KAGGLE_KEY }}" | base64 -w 0)
          
          # Injection dans gateway-secrets.yaml
          sed -i "s|secret-key: .*|secret-key: $SECRET_KEY_B64|g" k8s/base/api-gateway/gateway-secrets.yaml
          sed -i "s|database-url: .*|database-url: $DATABASE_URL_B64|g" k8s/base/api-gateway/gateway-secrets.yaml
          sed -i "s|google-client-id: .*|google-client-id: $GOOGLE_CLIENT_ID_B64|g" k8s/base/api-gateway/gateway-secrets.yaml
          sed -i "s|google-client-secret: .*|google-client-secret: $GOOGLE_CLIENT_SECRET_B64|g" k8s/base/api-gateway/gateway-secrets.yaml
          sed -i "s|oauth-redirect-url: .*|oauth-redirect-url: $OAUTH_REDIRECT_URL_B64|g" k8s/base/api-gateway/gateway-secrets.yaml
          
          # Injection dans kaggle-secrets.yaml
          sed -i "s|username: .*|username: $KAGGLE_USERNAME_B64|g" k8s/base/service-selection/kaggle-secrets.yaml
          sed -i "s|key: .*|key: $KAGGLE_KEY_B64|g" k8s/base/service-selection/kaggle-secrets.yaml
          
          echo "‚úÖ Secrets inject√©s dans les fichiers YAML"

      - name: üöÄ D√©ploiement automatique via script intelligent
        run: |
          echo "üöÄ Lancement du script de d√©ploiement intelligent..."
          chmod +x scripts/deploy-to-azure.sh
          
          # Le script utilisera automatiquement les variables d'environnement d√©couvertes
          echo "üìã Variables d'environnement pour le script:"
          echo "  AZURE_CONTAINER_REGISTRY=$AZURE_CONTAINER_REGISTRY"
          echo "  AKS_CLUSTER_NAME=$AKS_CLUSTER_NAME"
          echo "  AZURE_RESOURCE_GROUP=$AZURE_RESOURCE_GROUP"
          
          ./scripts/deploy-to-azure.sh

      - name: üìä V√©rification finale du d√©ploiement
        run: |
          echo "üìä V√©rification de l'√©tat final de l'application..."
          
          # Afficher l'√©tat des pods
          kubectl get pods -n ${{ env.K8S_NAMESPACE }}
          
          # Afficher l'√©tat des jobs
          kubectl get jobs -n ${{ env.K8S_NAMESPACE }}
          
          # Afficher les ingress
          kubectl get ingress -n ${{ env.K8S_NAMESPACE }}
          
          # R√©cup√©rer l'IP publique
          PUBLIC_IP=$(kubectl get svc -n ingress-nginx ingress-nginx-controller -o jsonpath='{.status.loadBalancer.ingress[0].ip}' 2>/dev/null || echo "N/A")
          echo "üåê IP publique de l'application: $PUBLIC_IP"
          
          # Test de connectivit√© (si IP disponible)
          if [[ "$PUBLIC_IP" != "N/A" ]] && [[ -n "$PUBLIC_IP" ]]; then
            echo "üß™ Test de connectivit√©..."
            curl -s -o /dev/null -w "Status: %{http_code}\n" "http://$PUBLIC_IP" || echo "Test de connectivit√© √©chou√©"
          fi

      - name: üìã R√©sum√© du d√©ploiement
        if: always()
        run: |
          echo "=================== R√âSUM√â D√âPLOIEMENT ==================="
          echo "‚úÖ Mode: Production (GitHub Actions avec d√©couverte automatique)"
          echo "‚úÖ ACR: $AZURE_CONTAINER_REGISTRY" 
          echo "‚úÖ AKS: $AKS_CLUSTER_NAME"
          echo "‚úÖ Resource Group: $AZURE_RESOURCE_GROUP"
          echo "‚úÖ Namespace: ${{ env.K8S_NAMESPACE }}"
          echo "‚úÖ Donn√©es: ${{ env.WITH_DATA }}"
          echo "==========================================================" 