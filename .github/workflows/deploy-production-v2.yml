name: Deploy Production IBIS-X v2 (Script Intelligent)

on:
  push:
    branches:
      - production
  workflow_dispatch:  # Permettre le d√©clenchement manuel

env:
  # Variables d'environnement pour le mode PRODUCTION
  GITHUB_ACTIONS: 'true'
  IS_PRODUCTION: 'true'
  
  # Configuration Azure (correspondent aux variables dans notre script)
  AZURE_CONTAINER_REGISTRY: 'ibisprodacr'
  AZURE_RESOURCE_GROUP: 'ibis-x-perso-rg'
  AKS_CLUSTER_NAME: 'ibis-x-prod-aks'
  K8S_NAMESPACE: 'ibis-x'
  
  # Configuration de l'application
  WITH_DATA: 'true'

jobs:
  deploy:
    name: üöÄ D√©ploiement Production Intelligent
    runs-on: ubuntu-latest
    
    steps:
      - name: üì• Checkout du code
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.PAT_TOKEN }}

      - name: üîê Connexion √† Azure
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: üõ†Ô∏è Installation des outils
        run: |
          # Installer jq pour le parsing JSON
          sudo apt-get update && sudo apt-get install -y jq
          
          # Installer kubectl (derni√®re version)
          curl -LO "https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl"
          sudo install -o root -g root -m 0755 kubectl /usr/local/bin/kubectl
          kubectl version --client
          
          # Installer Terraform
          wget -O- https://apt.releases.hashicorp.com/gpg | gpg --dearmor | sudo tee /usr/share/keyrings/hashicorp-archive-keyring.gpg
          echo "deb [signed-by=/usr/share/keyrings/hashicorp-archive-keyring.gpg] https://apt.releases.hashicorp.com $(lsb_release -cs) main" | sudo tee /etc/apt/sources.list.d/hashicorp.list
          sudo apt update && sudo apt install terraform

      - name: üîë Injection des secrets production dans les fichiers YAML
        run: |
          echo "üîê Injection des secrets de production dans les fichiers K8s..."
          
          # Encodage Base64 des secrets
          SECRET_KEY_B64=$(echo -n "${{ secrets.JWT_SECRET_KEY }}" | base64 -w 0)
          DATABASE_URL_B64=$(echo -n "${{ secrets.DATABASE_URL }}" | base64 -w 0)
          GOOGLE_CLIENT_ID_B64=$(echo -n "${{ secrets.GOOGLE_CLIENT_ID }}" | base64 -w 0)
          GOOGLE_CLIENT_SECRET_B64=$(echo -n "${{ secrets.GOOGLE_CLIENT_SECRET }}" | base64 -w 0)
          OAUTH_REDIRECT_URL_B64=$(echo -n "${{ secrets.OAUTH_REDIRECT_URL }}" | base64 -w 0)
          KAGGLE_USERNAME_B64=$(echo -n "${{ secrets.KAGGLE_USERNAME }}" | base64 -w 0)
          KAGGLE_KEY_B64=$(echo -n "${{ secrets.KAGGLE_KEY }}" | base64 -w 0)
          
          # Injection dans gateway-secrets.yaml
          sed -i "s|secret-key: .*|secret-key: $SECRET_KEY_B64|g" k8s/base/api-gateway/gateway-secrets.yaml
          sed -i "s|database-url: .*|database-url: $DATABASE_URL_B64|g" k8s/base/api-gateway/gateway-secrets.yaml
          sed -i "s|google-client-id: .*|google-client-id: $GOOGLE_CLIENT_ID_B64|g" k8s/base/api-gateway/gateway-secrets.yaml
          sed -i "s|google-client-secret: .*|google-client-secret: $GOOGLE_CLIENT_SECRET_B64|g" k8s/base/api-gateway/gateway-secrets.yaml
          sed -i "s|oauth-redirect-url: .*|oauth-redirect-url: $OAUTH_REDIRECT_URL_B64|g" k8s/base/api-gateway/gateway-secrets.yaml
          
          # Injection dans kaggle-secrets.yaml
          sed -i "s|username: .*|username: $KAGGLE_USERNAME_B64|g" k8s/base/service-selection/kaggle-secrets.yaml
          sed -i "s|key: .*|key: $KAGGLE_KEY_B64|g" k8s/base/service-selection/kaggle-secrets.yaml
          
          echo "‚úÖ Secrets inject√©s dans les fichiers YAML"

      - name: üöÄ D√©ploiement automatique via script intelligent
        run: |
          echo "üöÄ Lancement du script de d√©ploiement intelligent..."
          chmod +x scripts/deploy-to-azure.sh
          
          # Le script d√©tectera automatiquement l'environnement GitHub Actions
          # et utilisera les variables d'environnement d√©finies ci-dessus
          ./scripts/deploy-to-azure.sh

      - name: üìä V√©rification finale du d√©ploiement
        run: |
          echo "üìä V√©rification de l'√©tat final de l'application..."
          
          # Afficher l'√©tat des pods
          kubectl get pods -n ${{ env.K8S_NAMESPACE }}
          
          # Afficher l'√©tat des jobs
          kubectl get jobs -n ${{ env.K8S_NAMESPACE }}
          
          # Afficher les ingress
          kubectl get ingress -n ${{ env.K8S_NAMESPACE }}
          
          # R√©cup√©rer l'IP publique
          PUBLIC_IP=$(kubectl get svc -n ingress-nginx ingress-nginx-controller -o jsonpath='{.status.loadBalancer.ingress[0].ip}' 2>/dev/null || echo "N/A")
          echo "üåê IP publique de l'application: $PUBLIC_IP"
          
          # Test de connectivit√© (si IP disponible)
          if [[ "$PUBLIC_IP" != "N/A" ]] && [[ -n "$PUBLIC_IP" ]]; then
            echo "üß™ Test de connectivit√©..."
            curl -s -o /dev/null -w "Status: %{http_code}\n" "http://$PUBLIC_IP" || echo "Test de connectivit√© √©chou√©"
          fi

      - name: üìã R√©sum√© du d√©ploiement
        if: always()
        run: |
          echo "=================== R√âSUM√â D√âPLOIEMENT ==================="
          echo "‚úÖ Mode: Production (GitHub Actions)"
          echo "‚úÖ ACR: ${{ env.AZURE_CONTAINER_REGISTRY }}" 
          echo "‚úÖ AKS: ${{ env.AKS_CLUSTER_NAME }}"
          echo "‚úÖ Resource Group: ${{ env.AZURE_RESOURCE_GROUP }}"
          echo "‚úÖ Namespace: ${{ env.K8S_NAMESPACE }}"
          echo "‚úÖ Donn√©es: ${{ env.WITH_DATA }}"
          echo "==========================================================" 